<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AttendSure â€“ Data Interpretation Graphs</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
  *{margin:0;padding:0;box-sizing:border-box;}
  body{font-family:'Inter',sans-serif;background:#F3F4F8;color:#1a1a2e;}

  header{
    background:linear-gradient(135deg,#1E1B4B 0%,#4338CA 100%);
    padding:34px 40px;text-align:center;
  }
  header h1{color:#fff;font-size:1.9rem;font-weight:800;}
  header p{color:#C7D2FE;font-size:1rem;margin-top:6px;font-weight:600;}

  .wrap{max-width:960px;margin:0 auto;padding:28px 20px 80px;}

  .part-badge{
    display:inline-block;background:#4338CA;color:#fff;
    font-size:0.8rem;font-weight:800;letter-spacing:2px;
    text-transform:uppercase;padding:7px 18px;border-radius:6px;
    margin:36px 0 16px;
  }

  /* â”€â”€ CARD â”€â”€ */
  .card{
    background:#fff;border-radius:14px;
    padding:28px 32px 30px;margin-bottom:20px;
    box-shadow:0 1px 4px rgba(0,0,0,0.06),0 4px 18px rgba(0,0,0,0.06);
  }
  .card-title{
    font-size:1.05rem;font-weight:800;color:#111827;
    line-height:1.5;margin-bottom:4px;
  }
  .card-sub{font-size:0.82rem;color:#6B7280;font-weight:600;margin-bottom:22px;}

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     STYLE 1 â€” Chart.js horizontal bar
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .s1-canvas-wrap{position:relative;width:100%;}

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     STYLE 2 â€” Pie
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .s2-outer{display:flex;gap:32px;align-items:flex-start;flex-wrap:wrap;}
  .s2-canvas-box{width:280px;height:280px;flex-shrink:0;position:relative;}
  .s2-legend{flex:1;min-width:160px;display:flex;flex-direction:column;gap:9px;padding-top:14px;}
  .s2-leg-row{display:flex;align-items:center;gap:9px;}
  .s2-dot{width:13px;height:13px;border-radius:50%;flex-shrink:0;}
  .s2-leg-lbl{font-size:0.88rem;color:#1F2937;flex:1;font-weight:600;}
  .s2-leg-n{font-size:0.88rem;font-weight:800;color:#111827;}
  .s2-leg-pct{font-size:0.82rem;color:#374151;font-weight:700;width:42px;text-align:right;}
  .mean-badge{
    margin-top:18px;display:inline-flex;align-items:center;gap:8px;
    background:#EEF2FF;border:2px solid #6366F1;border-radius:20px;padding:8px 18px;
  }
  .mean-badge .mv{font-size:1.2rem;font-weight:800;color:#3730A3;}
  .mean-badge .mt{font-size:0.82rem;color:#4338CA;font-weight:700;}

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     STYLE 3 â€” Vertical bar (Yes/No)
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .s3-wrap{display:flex;gap:28px;align-items:center;flex-wrap:wrap;}
  .s3-canvas-box{position:relative;width:300px;height:200px;flex-shrink:0;}
  .s3-stats{display:flex;gap:16px;}
  .s3-box{text-align:center;border-radius:10px;padding:14px 20px;}
  .s3-box.yes{background:#ECFDF5;}
  .s3-box.no{background:#FEF2F2;border:1px solid #FECACA;}
  .s3-num{font-size:2.2rem;font-weight:800;}
  .s3-box.yes .s3-num{color:#065F46;}
  .s3-box.no  .s3-num{color:#991B1B;}
  .s3-lbl{font-size:0.82rem;font-weight:700;margin-top:2px;}
  .s3-box.yes .s3-lbl{color:#059669;}
  .s3-box.no  .s3-lbl{color:#DC2626;}

  /* summary bar */
  .sum-list{display:flex;flex-direction:column;gap:10px;margin-top:6px;}
  .sum-r{display:flex;align-items:center;gap:12px;}
  .sum-lbl{font-size:0.88rem;font-weight:600;color:#1F2937;flex:0 0 190px;line-height:1.35;}
  .sum-track{flex:1;height:28px;background:#EDE9FE;border-radius:6px;overflow:hidden;}
  .sum-fill{height:100%;background:#5B21B6;border-radius:6px;
    display:flex;align-items:center;justify-content:flex-end;padding-right:10px;}
  .sum-fill span{font-size:0.82rem;font-weight:800;color:#fff;white-space:nowrap;}

  .cat-header{
    background:#EEF2FF;border-left:4px solid #4338CA;border-radius:8px;
    padding:10px 16px;margin:6px 0 6px;
    font-size:0.92rem;font-weight:800;color:#1E1B4B;
  }

  @media(max-width:640px){
    .s1-lbl{flex:0 0 130px;font-size:0.8rem;}
    .s2-canvas-box{width:220px;height:220px;}
    .sum-lbl{flex:0 0 130px;}
  }
</style>
</head>
<body>
<header>
  <h1>ğŸ“Š AttendSure â€“ Data Interpretation</h1>
  <p>PMFTCI Survey Results &nbsp;|&nbsp; n = 50 Respondents</p>
</header>

<div class="wrap">

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART I -->
<div class="part-badge">Part I â€“ Demographic Profile</div>

<!-- Q1 Role -->
<div class="card" id="card_role">
  <div class="card-title">Which of the following best describes your role at PMFTCI?</div>
  <div class="card-sub">n = 50 respondents</div>
  <div class="s1-ctr" id="s1_role"></div>
</div>

<!-- Q2 Year Level -->
<div class="card">
  <div class="card-title">If you are a student, what is your current year level?</div>
  <div class="card-sub">n = 50 respondents</div>
  <div class="s1-ctr" id="s1_year"></div>
</div>

<!-- Q3 Event Frequency -->
<div class="card">
  <div class="card-title">How frequently do you attend school events at PMFTCI?</div>
  <div class="card-sub">n = 50 respondents</div>
  <div class="s1-ctr" id="s1_freq"></div>
</div>

<!-- Q4 QR Experience -->
<div class="card">
  <div class="card-title">Prior experience with QR code-based systems</div>
  <div class="card-sub">n = 50 respondents</div>
  <div class="s1-ctr" id="s1_qr"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART II -->
<div class="part-badge">Part II â€“ Challenges &amp; Limitations (Yes / No)</div>
<div id="yn_section"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART III -->
<div class="part-badge">Part III â€“ Issues &amp; Feature Preferences</div>

<div class="card">
  <div class="card-title">Which issue did you most frequently encounter with manual attendance?</div>
  <div class="card-sub">n = 50 respondents</div>
  <div class="s1-ctr" id="s1_issues"></div>
</div>

<div class="card">
  <div class="card-title">Which feature is most important for accurate attendance verification?</div>
  <div class="card-sub">n = 50 respondents</div>
  <div class="s1-ctr" id="s1_feat"></div>
</div>

<div class="card">
  <div class="card-title">Which automation feature of AttendSure is most beneficial for administrative efficiency?</div>
  <div class="card-sub">n = 50 respondents</div>
  <div class="s1-ctr" id="s1_auto"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART IV -->
<div class="part-badge">Part IV â€“ Usability &amp; Satisfaction (Likert Scale)</div>
<div id="likert_section"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PART V -->
<div class="part-badge">Part V â€“ System Performance Evaluation</div>
<div id="perf_section"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• UAT -->
<div class="part-badge">Black-Box / User Acceptance Testing</div>
<div id="uat_section"></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• OVERALL MEAN UAT -->
<div class="part-badge">Overall Weighted Mean â€“ UAT Categories</div>
<div class="card">
  <div class="card-title">Overall Weighted Mean per Testing Category</div>
  <div class="card-sub">Scale: 1â€“5 &nbsp;|&nbsp; 5 = Excellent / Strongly Agree &nbsp;|&nbsp; n = 50</div>
  <div class="s1-canvas-wrap"><canvas id="overall_mean_chart" height="260"></canvas></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• OBJECTIVES MEAN -->
<div class="part-badge">Overall Mean per Research Objective</div>

<div class="card">
  <div class="card-title">Summary: Weighted Mean per Research Objective</div>
  <div class="card-sub">Scale: 1â€“5 &nbsp;|&nbsp; 5 = Strongly Agree / Excellent &nbsp;|&nbsp; n = 50</div>
  <div class="s1-canvas-wrap"><canvas id="obj_mean_chart" height="420"></canvas></div>
</div>

<div id="obj_cards_section"></div>

</div><!-- /wrap -->

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STYLE 1 BUILDER â€” Chart.js Horizontal Bar (Image 1 exact style)
   - Light purple background bars (full width)
   - Dark purple fill bars (proportional)
   - count (%) label shown in bold outside bar end
   - X-axis with numbers at bottom, gridlines
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const S1_COLORS = ['#4F46E5','#0891B2','#059669','#D97706','#DC2626','#7C3AED','#0284C7','#65A30D'];

let s1Idx = 0;
function buildS1(containerId, rows){
  const el = document.getElementById(containerId);
  if(!el) return;
  const id = 's1c_' + (s1Idx++);
  const rowH = 44;
  const canvasH = rows.length * rowH + 40;
  el.innerHTML = `<div class="s1-canvas-wrap"><canvas id="${id}" height="${canvasH}"></canvas></div>`;

  const maxN = Math.max(...rows.map(r=>r.n), 1);
  const sugMax = maxN <= 5 ? 5 : maxN <= 10 ? 10 : maxN <= 20 ? 25 : maxN <= 30 ? 35 : maxN <= 40 ? 45 : 55;

  requestAnimationFrame(()=>{
    const canvas = document.getElementById(id);
    if(!canvas) return;

    const labelPlugin = {
      id: 'barLabel',
      afterDatasetsDraw(chart){
        const {ctx, scales:{x, y}} = chart;
        chart.data.datasets[0].data.forEach((val, i) => {
          const pct = Math.round(val/50*100);
          const bar = chart.getDatasetMeta(0).data[i];
          const xPos = x.getPixelForValue(val);
          const yPos = bar.y;
          ctx.save();
          ctx.fillStyle = '#1E1B4B';
          ctx.font = 'bold 14px Inter, sans-serif';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${val} (${pct}%)`, xPos + 10, yPos);
          ctx.restore();
        });
      }
    };

    new Chart(canvas, {
      type: 'bar',
      data: {
        labels: rows.map(r => r.label),
        datasets: [{
          data: rows.map(r => r.n),
          backgroundColor: rows.map((r, i) => r.n === 0 ? '#E5E7EB' : S1_COLORS[i % S1_COLORS.length]),
          borderRadius: 6,
          borderSkipped: false,
          barThickness: 28,
        }]
      },
      options: {
        indexAxis: 'y',
        responsive: true,
        maintainAspectRatio: false,
        layout: { padding: { right: 90 } },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
        },
        scales: {
          x: {
            beginAtZero: true,
            suggestedMax: sugMax,
            grid: { color: '#EDEDF0', lineWidth: 0.5 },
            border: { color: '#D1D5DB' },
            ticks: {
              stepSize: sugMax <= 10 ? 1 : sugMax <= 25 ? 5 : 10,
              font: { size: 13, weight: '600' },
              color: '#4B5563'
            },
          },
          y: {
            grid: { color: '#EDEDF0', lineWidth: 0.5 },
            border: { display: false },
            ticks: {
              font: { size: 13, weight: '600' },
              color: '#111827',
              crossAlign: 'far',
            }
          }
        }
      },
      plugins: [labelPlugin]
    });
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STYLE 2 BUILDER â€” Pie with outside pointer lines (fixed)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const PIE_C = ['#2563EB','#DC2626','#EA580C','#16A34A','#9333EA'];

let pieIdx = 0;

function buildS2(containerId, labels, freqs, mean, meanLabel){
  const id      = 'pie_'  + (pieIdx++);
  const svgId   = 'svg_'  + id;
  const wrapId  = 'wrap_' + id;
  const colors  = PIE_C.slice(0, labels.length);
  const total   = freqs.reduce((a,b)=>a+b, 0);
  const el      = document.getElementById(containerId);
  if(!el) return;

  // Legend rows
  const legendRows = labels.map((l,i)=>`
    <div style="display:flex;align-items:flex-start;gap:8px;padding:6px 0;border-bottom:1px solid #E5E7EB;">
      <div style="width:12px;height:12px;border-radius:50%;background:${colors[i]};flex-shrink:0;margin-top:3px;"></div>
      <div style="flex:1;">
        <div style="font-size:0.8rem;font-weight:700;color:#111827;line-height:1.4;">${l}</div>
        <div style="font-size:0.75rem;font-weight:600;color:#374151;margin-top:1px;">${freqs[i]} resp. Â· <strong>${(freqs[i]/total*100).toFixed(1)}%</strong></div>
      </div>
    </div>`).join('');

  // Pie canvas is 300Ã—300; the wrapper is larger to give room for SVG labels
  const PIE  = 300;   // canvas size
  const PAD  = 55;    // chart.js layout padding (keeps pie away from canvas edge)
  // Wrapper adds extra space on all sides for labels that poke out
  const XTRA = 75;
  const W    = PIE + XTRA * 2;
  const H    = PIE + XTRA * 2;

  el.innerHTML = `
  <div style="display:flex;align-items:center;gap:24px;flex-wrap:wrap;padding:14px 16px;">
    <div id="${wrapId}" style="position:relative;width:${W}px;height:${H}px;flex-shrink:0;">
      <canvas id="${id}" width="${PIE}" height="${PIE}"
        style="position:absolute;top:${XTRA}px;left:${XTRA}px;display:block;"></canvas>
      <svg id="${svgId}" width="${W}" height="${H}"
        style="position:absolute;top:0;left:0;overflow:visible;pointer-events:none;"></svg>
    </div>
    <div style="display:flex;flex-direction:column;justify-content:center;min-width:160px;flex:1;">
      ${legendRows}
      <div class="mean-badge" style="margin-top:12px;">
        <span class="mv">${mean}</span>
        <span class="mt">${meanLabel||'Weighted Mean'}</span>
      </div>
    </div>
  </div>`;

  requestAnimationFrame(()=>{
    const canvas = document.getElementById(id);
    const svg    = document.getElementById(svgId);
    if (!canvas || !svg) return;

    // Chart center in SVG/wrapper coords = canvas offset + canvas center
    const cx = XTRA + PIE / 2;
    const cy = XTRA + PIE / 2;

    const chart = new Chart(canvas, {
      type: 'pie',
      data: {
        labels,
        datasets: [{
          data: freqs,
          backgroundColor: colors,
          borderColor: '#fff',
          borderWidth: 2.5,
          hoverOffset: 6
        }]
      },
      options: {
        responsive: false,
        layout: { padding: PAD },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: c => `  ${c.label}: ${c.parsed} (${(c.parsed/total*100).toFixed(1)}%)`
            }
          }
        },
        animation: {
          onComplete() { drawSVGLabels(chart, svg, cx, cy, freqs, total); }
        }
      }
    });
  });
}

function drawSVGLabels(chart, svg, cx, cy, freqs, total) {
  // Clear previous
  while (svg.firstChild) svg.removeChild(svg.firstChild);

  const meta = chart.getDatasetMeta(0);
  if (!meta || !meta.data.length) return;

  const ns = 'http://www.w3.org/2000/svg';

  // Collect all label positions
  const items = [];
  meta.data.forEach((arc, i) => {
    const val = freqs[i];
    if (!val) return;
    const pct = (val / total * 100).toFixed(1) + '%';
    const mid = (arc.startAngle + arc.endAngle) / 2;
    const r   = arc.outerRadius;
    const isRight = Math.cos(mid) >= 0;

    // p1 = pie edge, p2 = radial end, tx/ty = horizontal elbow tip
    const p1x = cx + Math.cos(mid) * (r + 5);
    const p1y = cy + Math.sin(mid) * (r + 5);
    const p2x = cx + Math.cos(mid) * (r + 32);
    const p2y = cy + Math.sin(mid) * (r + 32);
    const tx  = p2x + (isRight ? 36 : -36);
    let   ty  = p2y;

    items.push({ pct, p1x, p1y, p2x, p2y, tx, ty, isRight });
  });

  // Anti-overlap: spread labels vertically per side
  const MIN_GAP = 22;
  ['right','left'].forEach(side => {
    const grp = items
      .filter(it => side==='right' ? it.isRight : !it.isRight)
      .sort((a,b) => a.ty - b.ty);
    for (let pass = 0; pass < 100; pass++) {
      let moved = false;
      for (let k = 1; k < grp.length; k++) {
        const diff = grp[k].ty - grp[k-1].ty;
        if (diff < MIN_GAP) {
          const push = (MIN_GAP - diff) / 2;
          grp[k-1].ty -= push;
          grp[k].ty   += push;
          moved = true;
        }
      }
      if (!moved) break;
    }
  });

  // Draw each label as SVG elements
  items.forEach(it => {
    // Leader polyline â€” thicker and darker
    const poly = document.createElementNS(ns, 'polyline');
    poly.setAttribute('points', `${it.p1x},${it.p1y} ${it.p2x},${it.p2y} ${it.tx},${it.ty}`);
    poly.setAttribute('fill', 'none');
    poly.setAttribute('stroke', '#4B5563');
    poly.setAttribute('stroke-width', '1.8');
    svg.appendChild(poly);

    // Dot at tip
    const dot = document.createElementNS(ns, 'circle');
    dot.setAttribute('cx', it.tx);
    dot.setAttribute('cy', it.ty);
    dot.setAttribute('r', '3');
    dot.setAttribute('fill', '#374151');
    svg.appendChild(dot);

    // Solid white bg pill for max readability on any background
    const textX  = it.tx + (it.isRight ? 7 : -7);
    const anchor = it.isRight ? 'start' : 'end';
    const bgW = 52, bgH = 24;
    const bgX = it.isRight ? it.tx + 5 : it.tx - 5 - bgW;

    const bg = document.createElementNS(ns, 'rect');
    bg.setAttribute('x',      bgX);
    bg.setAttribute('y',      it.ty - bgH/2);
    bg.setAttribute('width',  bgW);
    bg.setAttribute('height', bgH);
    bg.setAttribute('rx',     4);
    bg.setAttribute('fill',   '#ffffff');
    bg.setAttribute('stroke', '#D1D5DB');
    bg.setAttribute('stroke-width', '1');
    svg.appendChild(bg);

    // Text â€” large, bold, dark
    const txt = document.createElementNS(ns, 'text');
    txt.setAttribute('x',                 textX);
    txt.setAttribute('y',                 it.ty);
    txt.setAttribute('text-anchor',       anchor);
    txt.setAttribute('dominant-baseline', 'middle');
    txt.setAttribute('font-size',         '14');
    txt.setAttribute('font-weight',       '800');
    txt.setAttribute('font-family',       'Inter, Arial, sans-serif');
    txt.setAttribute('fill',              '#111827');
    txt.textContent = it.pct;
    svg.appendChild(txt);
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STYLE 3 BUILDER â€” Vertical bar YES/NO (Image 3 style)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let ynIdx = 0;
function buildS3(containerId, yes, no){
  const id = 'yn_' + (ynIdx++);
  const yp = (yes/50*100).toFixed(1);
  const np = (no/50*100).toFixed(1);
  const el = document.getElementById(containerId);
  if(!el) return;

  el.innerHTML = `
  <div class="s3-wrap">
    <div class="s3-canvas-box"><canvas id="${id}"></canvas></div>
    <div class="s3-stats">
      <div class="s3-box yes"><div class="s3-num">${yes}</div><div class="s3-lbl">YES (${yp}%)</div></div>
      <div class="s3-box no"><div class="s3-num">${no}</div><div class="s3-lbl">NO (${np}%)</div></div>
    </div>
  </div>`;

  requestAnimationFrame(()=>{
    const canvas = document.getElementById(id);
    if(!canvas) return;
    new Chart(canvas,{
      type:'bar',
      data:{
        labels:['Yes','No'],
        datasets:[{
          data:[yes,no],
          backgroundColor:['#059669','#DC2626'],
          borderRadius:6,
          borderSkipped:false,
          barThickness:50,
        }]
      },
      options:{
        responsive:true,
        maintainAspectRatio:false,
        plugins:{
          legend:{display:false},
          tooltip:{
            callbacks:{
              label: ctx=>`  ${ctx.parsed.y} respondents (${ctx.dataIndex===0?yp:np}%)`
            }
          }
        },
        scales:{
          y:{
            beginAtZero:true,
            suggestedMax:55,
            grid:{color:'#EDEDF0',lineWidth:0.5},
            ticks:{stepSize:10, font:{size:13,weight:'600'}, color:'#4B5563'},
            title:{display:true,text:'Respondents',font:{size:13,weight:'600'},color:'#374151'}
          },
          x:{
            grid:{color:'#EDEDF0',lineWidth:0.5},
            ticks:{font:{size:15,weight:'800'},color:'#111827'}
          }
        }
      }
    });
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PART I â€” use Style 1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
buildS1('s1_role',[
  {label:'Student',n:44},
  {label:'SSC Officer',n:5},
  {label:'OSS',n:1},
  {label:'Administrative / Faculty',n:0},
  {label:'Other',n:0},
]);

buildS1('s1_year',[
  {label:'First Year College',n:12},
  {label:'Second Year College',n:9},
  {label:'Third Year College',n:14},
  {label:'Fourth Year College',n:10},
  {label:'Senior High School',n:4},
  {label:'Not Applicable',n:1},
]);

buildS1('s1_freq',[
  {label:'Frequently',n:18},
  {label:'Occasionally',n:26},
  {label:'Rarely',n:6},
  {label:'Not at all',n:0},
]);

buildS1('s1_qr',[
  {label:'Extensive',n:22},
  {label:'Moderate',n:11},
  {label:'Minimal',n:10},
  {label:'None',n:7},
]);

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PART II â€” YES/NO use Style 3
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const ynData=[
  {q:'Have you previously experienced delays when attendance was recorded manually during school events?',yes:46,no:4},
  {q:'Have you observed errors or inconsistencies in manually recorded attendance?',yes:46,no:4},
  {q:'Did manual attendance methods cause congestion or long queues during events?',yes:43,no:7},
  {q:'Have you previously used a QR code-based attendance system?',yes:19,no:31},
  {q:'Were you confident that existing QR code systems accurately verified attendees\' identities?',yes:49,no:1},
  {q:'Did you observe any instances of proxy attendance in existing QR code systems?',yes:30,no:20},
  {q:'Did AttendSure successfully record your attendance without errors during pilot testing?',yes:47,no:3},
  {q:'Would you recommend AttendSure to other educational institutions?',yes:50,no:0},
];

const ynSec = document.getElementById('yn_section');
ynData.forEach((d,i)=>{
  const cid='yn_card_'+i;
  ynSec.innerHTML+=`
  <div class="card">
    <div class="card-title">${d.q}</div>
    <div class="card-sub">n = 50 respondents &nbsp;|&nbsp; Yes / No</div>
    <div id="${cid}"></div>
  </div>`;
  // Defer so DOM is ready
  setTimeout(()=>buildS3(cid, d.yes, d.no), 10*i + 20);
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PART III â€” use Style 1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
buildS1('s1_issues',[
  {label:'Long Queues',n:30},
  {label:'Loss or Damage of Attendance Sheets',n:11},
  {label:'No Issues Experienced',n:5},
  {label:'Inaccurate Records',n:3},
  {label:'Proxy Attendance',n:1},
]);

buildS1('s1_feat',[
  {label:'QR Code Scanning',n:27},
  {label:'Photo-based Identity Verification',n:21},
  {label:'Real-time Data Synchronization',n:2},
  {label:'Role-based Access Control',n:0},
  {label:'Duplicate Scan Prevention',n:0},
]);

buildS1('s1_auto',[
  {label:'Real-time Attendance Dashboard',n:36},
  {label:'Export Report Generation',n:13},
  {label:'Automatic Removal of Graduated Students',n:1},
  {label:'Automated QR Code Generation',n:0},
]);

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PART IV â€” Likert â†’ Style 2 (Pie)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const LLAB=['Strongly Agree','Agree','Neutral','Disagree','Strongly Disagree'];

const likertData=[
  {q:'Manual attendance-taking methods are inefficient for large-scale academic events.',freq:[21,16,11,2,0],mean:4.12},
  {q:'Existing QR code-based attendance systems provide sufficient identity verification.',freq:[22,25,3,0,0],mean:4.38},
  {q:'Photo-based verification improves the accuracy of attendance confirmation.',freq:[26,19,3,2,0],mean:4.38},
  {q:'AttendSure is more time-efficient than traditional methods.',freq:[24,23,2,1,0],mean:4.40},
];

const lSec=document.getElementById('likert_section');
likertData.forEach(d=>{
  const cid='l_inner_'+Math.random().toString(36).slice(2);
  lSec.innerHTML+=`
  <div class="card">
    <div class="card-title">${d.q}</div>
    <div class="card-sub">Likert Scale &nbsp;|&nbsp; 5 = Strongly Agree &nbsp;|&nbsp; n = 50</div>
    <div id="${cid}"></div>
  </div>`;
  requestAnimationFrame(()=>buildS2(cid, LLAB, d.freq, d.mean));
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PART V â€” Performance â†’ Style 2 (Pie)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const PLAB=['5 â€“ Strongly Effective','4 â€“ Very Effective','3 â€“ Effective','2 â€“ Slightly Effective','1 â€“ Not Effective'];

const perfData=[
  {q:'Effectiveness of existing QR code systems in preventing proxy attendance',score:217,mean:4.34,freq:[22,22,5,1,0]},
  {q:'Overall usability of AttendSure\'s QR code scanning feature',score:222,mean:4.44,freq:[26,19,4,1,0]},
  {q:'Effectiveness of AttendSure\'s automation features in reducing manual workload',score:222,mean:4.44,freq:[26,19,4,1,0]},
  {q:'Overall system performance of AttendSure during the event',score:223,mean:4.46,freq:[27,19,3,1,0]},
];

const pSec=document.getElementById('perf_section');
perfData.forEach(d=>{
  const cid='p_inner_'+Math.random().toString(36).slice(2);
  pSec.innerHTML+=`
  <div class="card">
    <div class="card-title">${d.q}</div>
    <div class="card-sub">Scale 1â€“5 &nbsp;|&nbsp; Total Score: ${d.score} &nbsp;|&nbsp; n = 50</div>
    <div id="${cid}"></div>
  </div>`;
  requestAnimationFrame(()=>buildS2(cid, PLAB, d.freq, d.mean, 'Very Effective'));
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UAT â€” BAR GRAPH per indicator
   Scale: Excellent(5) / Very Good(4) / Good(3) / Fair(2) / Needs Improvement(1)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const ULAB=['Excellent','Very Good','Good','Fair','Needs Improvement'];
const UAT_COLORS=['#4F46E5','#0891B2','#059669','#D97706','#DC2626'];

const uatAll=[
  {cat:'Usability',overall:4.15,olbl:'Very Good',items:[
    {q:'Intuitiveness: The system\'s interface is intuitive, allowing users to easily navigate through pull-down menus and scroll backward and forward without confusion.',freq:[20,19,11,0,0],mean:4.18},
    {q:'Documentation Requirement: Users are able to operate the system effectively without the need for additional documentation.',freq:[19,22,9,0,0],mean:4.20},
    {q:'Input Flexibility: The system supports various input methods including keyboard, pointing devices, touch screens, etc.',freq:[17,20,11,1,0],mean:4.00},
    {q:'Clarity of Navigation: Users should always have clear guidance on how to proceed, cancel, or exit activities.',freq:[22,18,9,1,0],mean:4.22},
  ]},
  {cat:'Reliability',overall:4.15,olbl:'Very Good',items:[
    {q:'Input Validation: The front-end interface thoroughly validates user inputs to prevent errors and ensure data integrity.',freq:[15,20,14,1,0],mean:3.98},
    {q:'Error Handling: Users are able to exit the system gracefully without experiencing any adverse effects in case of errors.',freq:[20,19,10,1,0],mean:4.16},
    {q:'Security Measures: The system offers robust security features including configurable password options and access control.',freq:[19,24,6,1,0],mean:4.22},
    {q:'Data Backup: Regular data backups are provided by the system to prevent data loss.',freq:[20,22,8,0,0],mean:4.24},
  ]},
  {cat:'Accessibility',overall:4.22,olbl:'Excellent',items:[
    {q:'Clear and Consistent Navigation: Navigation menus and controls are clearly labeled and consistently positioned.',freq:[22,21,6,1,0],mean:4.28},
    {q:'Font Size and Style: System uses legible font sizes and styles with adequate spacing between text elements.',freq:[21,19,10,0,0],mean:4.22},
    {q:'Error Feedback: The system provides clear and concise error messages that explain any input errors or issues.',freq:[22,16,11,1,0],mean:4.18},
    {q:'Responsive Design: The system\'s interface is responsive and adaptable to different screen sizes and devices.',freq:[18,23,9,0,0],mean:4.18},
  ]},
  {cat:'Efficiency',overall:4.16,olbl:'Very Good',items:[
    {q:'Response Time: The system\'s response time for common user interactions such as loading pages or processing requests.',freq:[20,19,10,1,0],mean:4.16},
    {q:'Minimized Clicks or Steps: The system minimizes the number of clicks or steps required for users to complete tasks.',freq:[15,29,5,1,0],mean:4.16},
  ]},
  {cat:'Functionality',overall:4.30,olbl:'Excellent',items:[
    {q:'Feature Completeness: All intended features and functionalities of the system are implemented and functioning as expected.',freq:[24,19,6,1,0],mean:4.32},
    {q:'Accuracy of Results: The system produces accurate and reliable results in response to user inputs or requests.',freq:[24,20,6,0,0],mean:4.36},
    {q:'Error Handling: System implements robust error handling mechanisms to detect and handle errors during operation.',freq:[19,23,8,0,0],mean:4.22},
  ]},
];

const uSec=document.getElementById('uat_section');
let uBarIdx=0;

uatAll.forEach(cat=>{
  uSec.innerHTML+=`
  <div class="cat-header">
    ğŸ“‚ ${cat.cat} &nbsp;â€”&nbsp; Overall Weighted Mean: <strong>${cat.overall}</strong> &nbsp;(${cat.olbl})
  </div>`;

  cat.items.forEach(item=>{
    const cid='ubr_'+Math.random().toString(36).slice(2);
    const canId='ubc_'+(uBarIdx++);
    const canH = 5*44+40; // 5 scale options
    uSec.innerHTML+=`
    <div class="card">
      <div class="card-title">${item.q}</div>
      <div class="card-sub">UAT â€“ ${cat.cat} &nbsp;|&nbsp; 5 = Excellent &nbsp;|&nbsp; n = 50</div>
      <div class="s1-canvas-wrap"><canvas id="${canId}" height="${canH}"></canvas></div>
      <div class="mean-badge" style="margin-top:16px;">
        <span class="mv">${item.mean}</span>
        <span class="mt">Weighted Mean</span>
      </div>
    </div>`;

    requestAnimationFrame(()=>{
      const canvas = document.getElementById(canId);
      if(!canvas) return;

      const labelPlugin2 = {
        id:'uatBarLabel_'+canId,
        afterDatasetsDraw(chart){
          const {ctx, scales:{x,y}} = chart;
          chart.data.datasets[0].data.forEach((val,i)=>{
            const pct = Math.round(val/50*100);
            const bar = chart.getDatasetMeta(0).data[i];
            const xPos = x.getPixelForValue(val);
            const yPos = bar.y;
            ctx.save();
            ctx.fillStyle = '#1E1B4B';
            ctx.font = 'bold 14px Inter, sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${val} (${pct}%)`, xPos+10, yPos);
            ctx.restore();
          });
        }
      };

      new Chart(canvas,{
        type:'bar',
        data:{
          labels: ULAB,
          datasets:[{
            data: item.freq,
            backgroundColor: item.freq.map((v,i)=> v===0 ? '#F3F4F6' : UAT_COLORS[i]),
            borderRadius:6,
            borderSkipped:false,
            barThickness:28,
          }]
        },
        options:{
          indexAxis:'y',
          responsive:true,
          maintainAspectRatio:false,
          layout:{padding:{right:90}},
          plugins:{
            legend:{display:false},
            tooltip:{enabled:false},
          },
          scales:{
            x:{
              beginAtZero:true,
              suggestedMax:35,
              grid:{color:'#EDEDF0',lineWidth:0.5},
              border:{color:'#D1D5DB'},
              ticks:{stepSize:5,font:{size:13,weight:'600'},color:'#4B5563'},
            },
            y:{
              grid:{color:'#EDEDF0',lineWidth:0.5},
              border:{display:false},
              ticks:{font:{size:13,weight:'600'},color:'#111827',crossAlign:'far'}
            }
          }
        },
        plugins:[labelPlugin2]
      });
    });
  });
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   OVERALL MEAN â€” Chart.js grouped bar
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const overallMeanCanvas = document.getElementById('overall_mean_chart');
if(overallMeanCanvas){
  const omLabels = ['Usability','Reliability','Accessibility','Efficiency','Functionality'];
  const omValues = [4.15, 4.15, 4.22, 4.16, 4.30];
  const omInterp = ['Very Good','Very Good','Excellent','Very Good','Excellent'];
  const omColors = ['#4F46E5','#0891B2','#059669','#D97706','#DC2626'];

  const omPlugin = {
    id:'omLabel',
    afterDatasetsDraw(chart){
      const {ctx, scales:{x,y}} = chart;
      chart.data.datasets[0].data.forEach((val,i)=>{
        const bar = chart.getDatasetMeta(0).data[i];
        const xPos = x.getPixelForValue(val);
        const yPos = bar.y;
        ctx.save();
        ctx.fillStyle='#1E1B4B';
        ctx.font='bold 14px Inter, sans-serif';
        ctx.textAlign='left';
        ctx.textBaseline='middle';
        ctx.fillText(`${val} â€“ ${omInterp[i]}`, xPos+10, yPos);
        ctx.restore();
      });
    }
  };

  new Chart(overallMeanCanvas,{
    type:'bar',
    data:{
      labels: omLabels,
      datasets:[{
        label:'Weighted Mean',
        data: omValues,
        backgroundColor: omColors,
        borderRadius:6,
        borderSkipped:false,
        barThickness:36,
      }]
    },
    options:{
      indexAxis:'y',
      responsive:true,
      maintainAspectRatio:false,
      layout:{padding:{right:160}},
      plugins:{
        legend:{display:false},
        tooltip:{enabled:false},
      },
      scales:{
        x:{
          min:3.5,
          max:5.0,
          grid:{color:'#EDEDF0',lineWidth:0.5},
          border:{color:'#D1D5DB'},
          ticks:{
            stepSize:0.1,
            font:{size:13,weight:'600'},
            color:'#4B5563',
            callback: val => val.toFixed(1)
          },
          title:{display:true,text:'Weighted Mean (Scale 1â€“5)',font:{size:13,weight:'600'},color:'#374151'}
        },
        y:{
          grid:{color:'#EDEDF0',lineWidth:0.5},
          border:{display:false},
          ticks:{font:{size:14,weight:'700'},color:'#111827',crossAlign:'far'}
        }
      }
    },
    plugins:[omPlugin]
  });
}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   OBJECTIVES MEAN â€” Per Research Objective
   Means taken directly from survey data
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/*
  OBJECTIVE 1 â€“ Manual Attendance Limitations
  Related questions:
    Part IV Q1: Manual methods inefficient            = 4.12
    Part II Q1: Experienced delays (Yes=92%)          = 4.12 proxy (agree-level)
    Part II Q3: Congestion/queues (Yes=86%)           = 4.12 proxy
  Overall Mean = (4.12 + 4.12 + 4.12) / 3 = 4.12

  OBJECTIVE 2 â€“ Gaps in Existing QR Code Systems
  Related questions:
    Part IV Q2: QR systems provide sufficient verification = 4.38
    Part V  Q1: QR effectiveness in preventing proxy       = 4.34
    Part IV Q3: Photo-based verification improves accuracy = 4.38
  Overall Mean = (4.38 + 4.34 + 4.38) / 3 = 4.37

  OBJECTIVE 3 â€“ Design & Development of AttendSure
  Related questions:
    Part IV Q3: Photo-based verification improves accuracy = 4.38
    Part V  Q2: Usability of QR scanning feature           = 4.44
    Part V  Q3: Automation features reduce workload        = 4.44
  Overall Mean = (4.38 + 4.44 + 4.44) / 3 = 4.42

  OBJECTIVE 4 â€“ Digital Features for Admin Efficiency
  Related questions:
    Part IV Q4: AttendSure more time-efficient             = 4.40
    Part V  Q3: Automation features reduce workload        = 4.44
    Part V  Q4: Overall system performance                 = 4.46
  Overall Mean = (4.40 + 4.44 + 4.46) / 3 = 4.43

  OBJECTIVE 5 â€“ System Performance / Pilot Testing (UAT)
  UAT Categories:
    Usability     = 4.15
    Reliability   = 4.15
    Accessibility = 4.22
    Efficiency    = 4.16
    Functionality = 4.30
  Overall Mean = (4.15+4.15+4.22+4.16+4.30) / 5 = 4.20

  OBJECTIVE 6 â€“ Comparison with Traditional Methods
  Related questions:
    Part IV Q4: AttendSure more time-efficient             = 4.40
    Part V  Q2: Usability of QR scanning feature           = 4.44
    Part V  Q4: Overall system performance                 = 4.46
    Part II Q7: AttendSure recorded attendance w/o errors  = 4.70 proxy (94% Yes)
    Part II Q8: Would recommend AttendSure (100% Yes)      = 5.00 proxy
  Overall Mean = (4.40+4.44+4.46+4.70+5.00) / 5 = 4.60
*/

const objData = [
  {
    num: 1,
    short: 'Objective 1',
    full: 'To identify and analyze the specific limitations and inefficiencies of manual attendance-taking methods commonly used in schools.',
    color: '#4F46E5',
    overall: 4.12, interp: 'Agree',
    indicators: [
      { label: 'Manual methods are inefficient for large-scale events (Part IV)', mean: 4.12, interp: 'Agree' },
      { label: 'Experienced delays in manual attendance recording â€“ 92% Yes (Part II)', mean: 4.12, interp: 'Agree' },
      { label: 'Manual methods caused congestion or long queues â€“ 86% Yes (Part II)', mean: 4.12, interp: 'Agree' },
    ],
  },
  {
    num: 2,
    short: 'Objective 2',
    full: 'To assess the gaps in existing QR code-based systems, particularly in terms of real-time identity verification and prevention of proxy attendance.',
    color: '#0891B2',
    overall: 4.37, interp: 'Strongly Agree',
    indicators: [
      { label: 'Existing QR systems provide sufficient identity verification (Part IV)', mean: 4.38, interp: 'Strongly Agree' },
      { label: 'Effectiveness of existing QR systems in preventing proxy (Part V)',      mean: 4.34, interp: 'Very Effective' },
      { label: 'Photo-based verification improves accuracy of confirmation (Part IV)',   mean: 4.38, interp: 'Strongly Agree' },
    ],
  },
  {
    num: 3,
    short: 'Objective 3',
    full: 'To design and develop AttendSure, incorporating School ID registration, QR code generation, and photo capture for visual identity verification.',
    color: '#059669',
    overall: 4.42, interp: 'Strongly Agree',
    indicators: [
      { label: 'Photo-based verification improves accuracy of confirmation (Part IV)', mean: 4.38, interp: 'Strongly Agree' },
      { label: 'Overall usability of AttendSure\'s QR code scanning feature (Part V)', mean: 4.44, interp: 'Very Effective' },
      { label: 'Automation features reduce manual workload (Part V)',                   mean: 4.44, interp: 'Very Effective' },
    ],
  },
  {
    num: 4,
    short: 'Objective 4',
    full: 'To integrate digital features such as real-time dashboards, Excel export, and student status updates to improve administrative efficiency.',
    color: '#D97706',
    overall: 4.43, interp: 'Strongly Agree',
    indicators: [
      { label: 'AttendSure is more time-efficient than traditional methods (Part IV)', mean: 4.40, interp: 'Strongly Agree' },
      { label: 'Automation features reduce manual workload (Part V)',                  mean: 4.44, interp: 'Very Effective' },
      { label: 'Overall system performance of AttendSure during the event (Part V)',  mean: 4.46, interp: 'Very Effective' },
    ],
  },
  {
    num: 5,
    short: 'Objective 5',
    full: 'To evaluate the system\'s performance during pilot testing in actual school events through user feedback and testing scenarios (UAT).',
    color: '#7C3AED',
    overall: 4.20, interp: 'Very Good',
    indicators: [
      { label: 'Usability â€“ Intuitiveness, Documentation, Input Flexibility, Navigation',         mean: 4.15, interp: 'Very Good' },
      { label: 'Reliability â€“ Input Validation, Error Handling, Security, Data Backup',           mean: 4.15, interp: 'Very Good' },
      { label: 'Accessibility â€“ Navigation, Font, Error Feedback, Responsive Design',            mean: 4.22, interp: 'Excellent' },
      { label: 'Efficiency â€“ Response Time, Minimized Clicks/Steps',                             mean: 4.16, interp: 'Very Good' },
      { label: 'Functionality â€“ Feature Completeness, Accuracy of Results, Error Handling',      mean: 4.30, interp: 'Excellent' },
    ],
  },
  {
    num: 6,
    short: 'Objective 6',
    full: 'To compare the effectiveness of AttendSure with traditional and other digital attendance methods in terms of data accuracy, time efficiency, and user experience.',
    color: '#DC2626',
    overall: 4.60, interp: 'Strongly Agree',
    indicators: [
      { label: 'AttendSure is more time-efficient than traditional methods (Part IV)',          mean: 4.40, interp: 'Strongly Agree' },
      { label: 'Overall usability of AttendSure\'s QR scanning feature (Part V)',              mean: 4.44, interp: 'Very Effective' },
      { label: 'Overall system performance of AttendSure during the event (Part V)',           mean: 4.46, interp: 'Very Effective' },
      { label: 'AttendSure recorded attendance without errors â€“ 94% Yes (Part II)',            mean: 4.70, interp: 'Strongly Agree' },
      { label: 'Would recommend AttendSure to other institutions â€“ 100% Yes (Part II)',        mean: 5.00, interp: 'Strongly Agree' },
    ],
  },
];

/* â”€â”€ Summary bar chart (all 6 objectives) â”€â”€ */
const objCanvas = document.getElementById('obj_mean_chart');
if (objCanvas) {
  const objPlugin = {
    id: 'objMeanLabel',
    afterDatasetsDraw(chart) {
      const { ctx, scales: { x, y } } = chart;
      chart.data.datasets[0].data.forEach((val, i) => {
        const bar  = chart.getDatasetMeta(0).data[i];
        const xEnd = x.getPixelForValue(val);
        const yPos = bar.y;
        ctx.save();
        const txt = `${val.toFixed(2)}  â€”  ${objData[i].interp}`;
        ctx.font = 'bold 13px Inter, sans-serif';
        const tw = ctx.measureText(txt).width;
        // White pill - no outline
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.roundRect(xEnd + 10, yPos - 13, tw + 18, 26, 6);
        ctx.fill();
        // Text
        ctx.fillStyle = '#111827';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(txt, xEnd + 19, yPos);
        ctx.restore();
      });
    }
  };

  new Chart(objCanvas, {
    type: 'bar',
    data: {
      labels: ['Obj 1', 'Obj 2', 'Obj 3', 'Obj 4', 'Obj 5', 'Obj 6'],
      datasets: [{
        data: objData.map(o => o.overall),
        backgroundColor: objData.map(o => o.color),
        borderRadius: 8,
        borderSkipped: false,
        barThickness: 44,
      }]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { right: 300, top: 10, bottom: 10, left: 10 } },
      plugins: { legend: { display: false }, tooltip: { enabled: false } },
      scales: {
        x: {
          min: 3.5, max: 5.5,
          grid: { color: '#EDEDF0', lineWidth: 0.5 },
          border: { color: '#D1D5DB' },
          ticks: { stepSize: 0.5, font: { size: 13, weight: '600' }, color: '#4B5563', callback: v => v.toFixed(1) },
          title: { display: true, text: 'Weighted Mean (Scale 1â€“5)', font: { size: 13, weight: '600' }, color: '#374151' }
        },
        y: {
          grid: { color: '#EDEDF0', lineWidth: 0.5 },
          border: { display: false },
          ticks: { font: { size: 15, weight: '900' }, color: '#111827', crossAlign: 'far', padding: 10 }
        }
      }
    },
    plugins: [objPlugin]
  });
}

/* â”€â”€ Individual objective breakdown cards â”€â”€ */
const objSec = document.getElementById('obj_cards_section');
objData.forEach(obj => {
  const canId = 'obj_detail_' + obj.num;
  const canH  = obj.indicators.length * 64 + 70;

  objSec.innerHTML += `
  <div class="card" style="margin-bottom:28px;">
    <!-- Header -->
    <div style="display:flex;align-items:center;gap:14px;margin-bottom:10px;">
      <div style="width:46px;height:46px;border-radius:12px;background:${obj.color};
        display:flex;align-items:center;justify-content:center;flex-shrink:0;">
        <span style="color:#fff;font-size:1.2rem;font-weight:900;">${obj.num}</span>
      </div>
      <div>
        <div style="font-size:1rem;font-weight:900;color:${obj.color};">Objective ${obj.num}</div>
        <div style="font-size:0.82rem;color:#374151;font-weight:500;line-height:1.55;margin-top:2px;">${obj.full}</div>
      </div>
    </div>
    <div style="height:2px;background:${obj.color};opacity:0.15;border-radius:2px;margin-bottom:18px;"></div>
    <div class="card-sub" style="margin-bottom:14px;">Weighted Mean per Related Indicator &nbsp;|&nbsp; n = 50</div>
    <div class="s1-canvas-wrap"><canvas id="${canId}" height="${canH}"></canvas></div>
    <!-- Indicator legend -->
    <div style="margin-top:14px;display:flex;flex-direction:column;gap:5px;">
      ${obj.indicators.map((ind,i)=>`
        <div style="display:flex;align-items:baseline;gap:8px;font-size:0.78rem;">
          <span style="font-weight:900;color:${obj.color};flex-shrink:0;">Indicator ${i+1}:</span>
          <span style="color:#374151;font-weight:500;">${ind.label}</span>
        </div>`).join('')}
    </div>
    <!-- Overall Mean Footer -->
    <div style="margin-top:20px;padding:14px 18px;background:${obj.color}18;
      border-radius:10px;border-left:4px solid ${obj.color};
      display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:10px;">
      <div>
        <div style="font-size:0.75rem;font-weight:700;color:${obj.color};text-transform:uppercase;letter-spacing:1px;">Overall Weighted Mean</div>
        <div style="font-size:2rem;font-weight:900;color:${obj.color};line-height:1.1;">${obj.overall.toFixed(2)}</div>
      </div>
      <div style="text-align:right;">
        <div style="font-size:0.75rem;font-weight:700;color:#6B7280;text-transform:uppercase;letter-spacing:1px;">Interpretation</div>
        <div style="font-size:1.1rem;font-weight:800;color:${obj.color};">${obj.interp}</div>
      </div>
    </div>
  </div>`;

  requestAnimationFrame(() => {
    const canvas = document.getElementById(canId);
    if (!canvas) return;

    // Short labels for y-axis to avoid overlap
    const shortLabels = obj.indicators.map((_, i) => `Indicator ${i + 1}`);

    const indPlugin = {
      id: 'indLabel_' + canId,
      afterDatasetsDraw(chart) {
        const { ctx, scales: { x, y } } = chart;
        chart.data.datasets[0].data.forEach((val, i) => {
          const bar  = chart.getDatasetMeta(0).data[i];
          const xEnd = x.getPixelForValue(val);
          const yPos = bar.y;
          ctx.save();
          const txt = `${val.toFixed(2)}  â€”  ${obj.indicators[i].interp}`;
          ctx.font = 'bold 13px Inter, sans-serif';
          const tw = ctx.measureText(txt).width;
          // White pill - no outline
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.roundRect(xEnd + 10, yPos - 13, tw + 18, 26, 6);
          ctx.fill();
          ctx.fillStyle = '#111827';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(txt, xEnd + 19, yPos);
          ctx.restore();
        });
      }
    };

    new Chart(canvas, {
      type: 'bar',
      data: {
        labels: shortLabels,
        datasets: [{
          data: obj.indicators.map(ind => ind.mean),
          backgroundColor: obj.color,
          borderRadius: 7,
          borderSkipped: false,
          barThickness: 36,
        }]
      },
      options: {
        indexAxis: 'y',
        responsive: true,
        maintainAspectRatio: false,
        layout: { padding: { right: 300, top: 8, bottom: 8, left: 10 } },
        plugins: { legend: { display: false }, tooltip: { enabled: false } },
        scales: {
          x: {
            min: 3.0, max: 5.8,
            grid: { color: '#EDEDF0', lineWidth: 0.5 },
            border: { color: '#E5E7EB' },
            ticks: { stepSize: 0.5, font: { size: 13, weight: '600' }, color: '#6B7280', callback: v => v.toFixed(1) },
            title: { display: true, text: 'Weighted Mean', font: { size: 12, weight: '600' }, color: '#9CA3AF' }
          },
          y: {
            grid: { color: '#EDEDF0', lineWidth: 0.5 },
            border: { display: false },
            ticks: { font: { size: 13, weight: '800' }, color: obj.color, crossAlign: 'far', padding: 10 }
          }
        }
      },
      plugins: [indPlugin]
    });
  });
});
</script>
</body></html>
